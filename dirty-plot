#!/usr/local/bin/python3

import time
import dateutil.parser
import logging
import fileinput

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def try_pandas(s,fn):
    want_pandas = True
    if want_pandas:
        try:
            import pandas as pd
        except:
            return

    df=pd.DataFrame(s)
    df.to_json(fn)
    logger.debug("pandas saved to '%s'",fn)

    combined={}
    for section, metrics in df.items():
        for metric,rows in metrics.items():
            list_ts=[]
            list_val=[]
            list_metric=[]

            for row in rows:
                for ts in row.keys():
                    val=row[ts]
                    list_ts.append(ts)
                    list_val.append(val)
                    list_metric.append(metric)

            ts_series=pd.to_datetime(list_ts)
            val_series=pd.to_numeric(list_val)
            metric_series=pd.Series(list_metric)

            ts_df=pd.DataFrame(ts_series,columns=["Time"])
            val_df=pd.DataFrame(val_series,columns=[metric])
            metric_df=pd.DataFrame(metric_series,columns=["Metric"])

            all_df=pd.concat([ts_df,val_df,metric_df],axis=1)
            all_df.set_index('Time',inplace=True)
            combined[metric]=all_df

        # This part will return after processing only one section; all there is so far.
        return combined

def main():
    section="meminfo"
    sets={section:{}}

    for l in fileinput.input():
        l=l.strip()
        (ts,key,val)=str.split(l,"\t",2)
        t=dateutil.parser.parse(ts)
        epoch=time.mktime(t.timetuple())
        formatted="%s %s" % (epoch,val)

        # Backward compatible output
        if key=="Dirty":
            if (False):  print (formatted)

        value=float(val)
        if key not in sets[section]:
            sets[section][key] = []
        sets[section][key].append({t:value})

    return try_pandas(sets,'%s.json' % section)

if __name__ == '__main__':
    df=main()

    
